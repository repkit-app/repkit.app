/**
 * Authentication Interceptor
 * Validates HMAC signature and timestamp on all Connect RPC requests
 */

import { createHmac } from 'crypto';
import type { Interceptor } from '@connectrpc/connect';
import { Code, ConnectError } from '@connectrpc/connect';
import { anonymize } from '@/lib/utils/anonymize';
import { logger } from '@/lib/utils/logger';

/**
 * Authentication Interceptor
 * Validates HMAC-SHA256 signature and timestamp to prevent unauthorized access
 *
 * Signature validation:
 * - Extracts signature and timestamp from request message
 * - Computes HMAC-SHA256(payload + timestamp) using HMAC_SECRET
 * - Compares with provided signature
 *
 * Timestamp validation:
 * - Prevents replay attacks by enforcing 5-minute window
 * - Request timestamp must be within Â±5 minutes of server time
 *
 * Error handling:
 * - Returns UNAUTHENTICATED (401) if validation fails
 * - Does NOT forward to handlers if auth fails
 * - Logs anonymized identifiers for security monitoring
 */
export const authInterceptor: Interceptor = (next) => {
  return async (req) => {
    // Extract auth fields from request message
    // These are included in the proto message, not in HTTP headers
    const msg = req.message as Record<string, unknown>;
    const signature = msg.signature;
    const timestamp = msg.timestamp;
    const deviceToken = msg.deviceToken;

    // Validate fields exist
    if (!signature || !timestamp) {
      logger.warn('Missing authentication fields', {
        method: req.method.name,
        url: req.url,
      });

      throw new ConnectError(
        'Authentication required: missing signature or timestamp',
        Code.Unauthenticated
      );
    }

    // Validate timestamp is recent (within 5 minutes)
    const requestTime = parseInt(String(timestamp), 10);

    // Reject if timestamp is NaN (invalid number) - prevents bypass attacks
    if (isNaN(requestTime)) {
      logger.warn('Invalid timestamp format', {
        method: req.method.name,
        timestamp,
      });

      throw new ConnectError(
        'Authentication failed: invalid timestamp format',
        Code.Unauthenticated
      );
    }

    const serverTime = Date.now();
    const timeDiffMs = Math.abs(serverTime - requestTime);
    const fiveMinutesMs = 5 * 60 * 1000;

    if (timeDiffMs > fiveMinutesMs) {
      logger.warn('Timestamp validation failed', {
        method: req.method.name,
        identifier: deviceToken
          ? `token#${anonymize(String(deviceToken))}`
          : 'unknown',
        timeDiffSeconds: (timeDiffMs / 1000).toFixed(1),
      });

      throw new ConnectError(
        `Authentication failed: request timestamp outside valid window (${(timeDiffMs / 1000).toFixed(1)}s old)`,
        Code.Unauthenticated
      );
    }

    // Validate HMAC signature
    // The signature is computed over: proto binary message (WITHOUT signature field) + timestamp
    // This is more robust than JSON because:
    // - Future-proof: proto evolution is handled properly
    // - No hidden field selection: actual message bytes are signed
    // - Language-agnostic: binary format is standard across implementations
    const secret = process.env.HMAC_SECRET;

    // In production, HMAC_SECRET is required to prevent authentication bypass
    if (!secret && process.env.NODE_ENV === 'production') {
      throw new Error(
        'HMAC_SECRET environment variable is required in production for request authentication'
      );
    }

    const fallbackSecret = secret || 'change-me-in-prod';

    try {
      // Create a clean copy of the message WITHOUT the signature field for verification
      // The original message includes signature, timestamp, and payload fields
      // We sign only the payload fields (messages, tools, temperature, etc.)
      const msgCopy = { ...msg } as Record<string, unknown>;
      msgCopy.signature = undefined;

      // Serialize message to proto binary (without signature field)
      // The proto message has toBinary() method auto-generated by protoc-gen-es
      const msgWithBinary = msgCopy as { toBinary?: () => Buffer };
      const messageBytes = msgWithBinary.toBinary?.() || Buffer.from('');

      const payload = Buffer.concat([
        messageBytes,
        Buffer.from(String(timestamp), 'utf-8'),
      ]);

      const expectedSignature = createHmac('sha256', fallbackSecret)
        .update(payload)
        .digest('hex');

      if (String(signature) !== expectedSignature) {
        const identifier = deviceToken
          ? `token#${anonymize(String(deviceToken))}`
          : 'unknown';

        logger.warn('Signature validation failed', {
          method: req.method.name,
          identifier,
        });

        throw new ConnectError(
          'Authentication failed: invalid signature',
          Code.Unauthenticated
        );
      }

      // Signature valid - forward request to next handler
      return await next(req);
    } catch (error) {
      if (error instanceof ConnectError) {
        throw error;
      }

      logger.error('Unexpected error during signature validation', error instanceof Error ? error : null, {
        errorType: error instanceof Error ? error.constructor.name : typeof error,
      });

      throw new ConnectError(
        'Authentication error',
        Code.Internal
      );
    }
  };
};
