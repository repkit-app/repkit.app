/**
 * Authentication Interceptor
 * Validates HMAC signature and timestamp on all Connect RPC requests
 */

import { createHmac } from 'crypto';
import type { Interceptor } from '@connectrpc/connect';
import { Code, ConnectError } from '@connectrpc/connect';
import { anonymize } from '@/lib/utils/anonymize';
import { logger } from '@/lib/utils/logger';

/**
 * Authentication Interceptor
 * Validates HMAC-SHA256 signature and timestamp to prevent unauthorized access
 *
 * Signature validation:
 * - Extracts signature and timestamp from request message
 * - Computes HMAC-SHA256(payload + timestamp) using HMAC_SECRET
 * - Compares with provided signature
 *
 * Timestamp validation:
 * - Prevents replay attacks by enforcing 5-minute window
 * - Request timestamp must be within Â±5 minutes of server time
 *
 * Error handling:
 * - Returns UNAUTHENTICATED (401) if validation fails
 * - Does NOT forward to handlers if auth fails
 * - Logs anonymized identifiers for security monitoring
 */
export const authInterceptor: Interceptor = (next) => {
  return async (req) => {
    // Extract auth fields from request message
    // These are included in the proto message, not in HTTP headers
    const msg = req.message;
    const signature = (msg as any).signature;
    const timestamp = (msg as any).timestamp;
    const deviceToken = (msg as any).deviceToken;

    // Validate fields exist
    if (!signature || !timestamp) {
      logger.warn('Missing authentication fields', {
        method: req.method.name,
        url: req.url,
      });

      throw new ConnectError(
        'Authentication required: missing signature or timestamp',
        Code.Unauthenticated
      );
    }

    // Validate timestamp is recent (within 5 minutes)
    const requestTime = parseInt(timestamp, 10);
    const serverTime = Date.now();
    const timeDiffMs = Math.abs(serverTime - requestTime);
    const fiveMinutesMs = 5 * 60 * 1000;

    if (timeDiffMs > fiveMinutesMs) {
      logger.warn('Timestamp validation failed', {
        method: req.method.name,
        identifier: deviceToken
          ? `token#${anonymize(deviceToken)}`
          : 'unknown',
        timeDiffSeconds: (timeDiffMs / 1000).toFixed(1),
      });

      throw new ConnectError(
        `Authentication failed: request timestamp outside valid window (${(timeDiffMs / 1000).toFixed(1)}s old)`,
        Code.Unauthenticated
      );
    }

    // Validate HMAC signature
    // The signature is computed over: proto binary message + timestamp
    // This is more robust than JSON because:
    // - Future-proof: proto evolution is handled properly
    // - No hidden field selection: actual message bytes are signed
    // - Language-agnostic: binary format is standard across implementations
    const secret = process.env.HMAC_SECRET || 'change-me-in-prod';

    try {
      // Serialize message to proto binary
      // The proto message has toBinary() method auto-generated by protoc-gen-es
      const messageBytes = (msg as any).toBinary?.() || Buffer.from('');

      const payload = Buffer.concat([
        messageBytes,
        Buffer.from(timestamp, 'utf-8'),
      ]);

      const expectedSignature = createHmac('sha256', secret)
        .update(payload)
        .digest('hex');

      if (signature !== expectedSignature) {
        const identifier = deviceToken
          ? `token#${anonymize(deviceToken)}`
          : 'unknown';

        logger.warn('Signature validation failed', {
          method: req.method.name,
          identifier,
        });

        throw new ConnectError(
          'Authentication failed: invalid signature',
          Code.Unauthenticated
        );
      }

      // Signature valid - forward request to next handler
      return await next(req);
    } catch (error) {
      if (error instanceof ConnectError) {
        throw error;
      }

      logger.error('Unexpected error during signature validation', error instanceof Error ? error : null, {
        errorType: error instanceof Error ? error.constructor.name : typeof error,
      });

      throw new ConnectError(
        'Authentication error',
        Code.Internal
      );
    }
  };
};
