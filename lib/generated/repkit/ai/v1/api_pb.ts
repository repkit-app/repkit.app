// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file repkit/ai/v1/api.proto (package repkit.ai.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message as Message$1, proto3 } from "@bufbuild/protobuf";

/**
 * *
 * Chat message types for OpenAI API
 * Supports system, user, assistant, and tool roles
 *
 * @generated from message repkit.ai.v1.ChatMessage
 */
export class ChatMessage extends Message$1<ChatMessage> {
  /**
   * @generated from field: repkit.ai.v1.ChatMessage.Role role = 1;
   */
  role = ChatMessage_Role.UNSPECIFIED;

  /**
   * Can be null for tool calls
   *
   * @generated from field: optional string content = 2;
   */
  content?: string;

  /**
   * Function name for tool results
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * Required when role is TOOL
   *
   * @generated from field: optional string tool_call_id = 4;
   */
  toolCallId?: string;

  /**
   * For assistant messages with tool calls
   *
   * @generated from field: repeated repkit.ai.v1.ToolCall tool_calls = 5;
   */
  toolCalls: ToolCall[] = [];

  constructor(data?: PartialMessage<ChatMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ChatMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "enum", T: proto3.getEnumType(ChatMessage_Role) },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "tool_call_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "tool_calls", kind: "message", T: ToolCall, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessage {
    return new ChatMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessage | PlainMessage<ChatMessage> | undefined, b: ChatMessage | PlainMessage<ChatMessage> | undefined): boolean {
    return proto3.util.equals(ChatMessage, a, b);
  }
}

/**
 * @generated from enum repkit.ai.v1.ChatMessage.Role
 */
export enum ChatMessage_Role {
  /**
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ROLE_SYSTEM = 1;
   */
  SYSTEM = 1,

  /**
   * @generated from enum value: ROLE_USER = 2;
   */
  USER = 2,

  /**
   * @generated from enum value: ROLE_ASSISTANT = 3;
   */
  ASSISTANT = 3,

  /**
   * @generated from enum value: ROLE_TOOL = 4;
   */
  TOOL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ChatMessage_Role)
proto3.util.setEnumType(ChatMessage_Role, "repkit.ai.v1.ChatMessage.Role", [
  { no: 0, name: "ROLE_UNSPECIFIED" },
  { no: 1, name: "ROLE_SYSTEM" },
  { no: 2, name: "ROLE_USER" },
  { no: 3, name: "ROLE_ASSISTANT" },
  { no: 4, name: "ROLE_TOOL" },
]);

/**
 * *
 * Tool call information returned by assistant messages
 *
 * @generated from message repkit.ai.v1.ToolCall
 */
export class ToolCall extends Message$1<ToolCall> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Always "function"
   *
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: repkit.ai.v1.ToolFunction function = 3;
   */
  function?: ToolFunction;

  constructor(data?: PartialMessage<ToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "function", kind: "message", T: ToolFunction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolCall {
    return new ToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolCall {
    return new ToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolCall {
    return new ToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: ToolCall | PlainMessage<ToolCall> | undefined, b: ToolCall | PlainMessage<ToolCall> | undefined): boolean {
    return proto3.util.equals(ToolCall, a, b);
  }
}

/**
 * *
 * Function definition within a tool call
 *
 * @generated from message repkit.ai.v1.ToolFunction
 */
export class ToolFunction extends Message$1<ToolFunction> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * JSON string (OpenAI format)
   *
   * @generated from field: string arguments = 2;
   */
  arguments = "";

  constructor(data?: PartialMessage<ToolFunction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolFunction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arguments", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolFunction {
    return new ToolFunction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolFunction {
    return new ToolFunction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolFunction {
    return new ToolFunction().fromJsonString(jsonString, options);
  }

  static equals(a: ToolFunction | PlainMessage<ToolFunction> | undefined, b: ToolFunction | PlainMessage<ToolFunction> | undefined): boolean {
    return proto3.util.equals(ToolFunction, a, b);
  }
}

/**
 * *
 * JSON Schema parameter definition for a tool function
 * Subset of JSON Schema specification
 *
 * @generated from message repkit.ai.v1.ToolParameter
 */
export class ToolParameter extends Message$1<ToolParameter> {
  /**
   * "string", "number", "boolean", "array", "object"
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * Allowed values for this parameter
   *
   * @generated from field: repeated string enum = 3;
   */
  enum: string[] = [];

  /**
   * For extensibility
   *
   * @generated from field: map<string, string> additional_properties = 4;
   */
  additionalProperties: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ToolParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "enum", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "additional_properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolParameter {
    return new ToolParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolParameter {
    return new ToolParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolParameter {
    return new ToolParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ToolParameter | PlainMessage<ToolParameter> | undefined, b: ToolParameter | PlainMessage<ToolParameter> | undefined): boolean {
    return proto3.util.equals(ToolParameter, a, b);
  }
}

/**
 * *
 * Tool parameter schema (JSON Schema object type)
 * Defines the parameters object for a tool function
 *
 * @generated from message repkit.ai.v1.ToolSchema
 */
export class ToolSchema extends Message$1<ToolSchema> {
  /**
   * Required: keys must be in this map
   *
   * @generated from field: map<string, repkit.ai.v1.ToolSchema.Property> properties = 1;
   */
  properties: { [key: string]: ToolSchema_Property } = {};

  /**
   * Which properties are required
   *
   * @generated from field: repeated string required = 2;
   */
  required: string[] = [];

  constructor(data?: PartialMessage<ToolSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ToolSchema_Property} },
    { no: 2, name: "required", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolSchema {
    return new ToolSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolSchema {
    return new ToolSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolSchema {
    return new ToolSchema().fromJsonString(jsonString, options);
  }

  static equals(a: ToolSchema | PlainMessage<ToolSchema> | undefined, b: ToolSchema | PlainMessage<ToolSchema> | undefined): boolean {
    return proto3.util.equals(ToolSchema, a, b);
  }
}

/**
 * *
 * Property definition for each parameter
 *
 * @generated from message repkit.ai.v1.ToolSchema.Property
 */
export class ToolSchema_Property extends Message$1<ToolSchema_Property> {
  /**
   * JSON Schema type
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * @generated from field: repeated string enum = 3;
   */
  enum: string[] = [];

  constructor(data?: PartialMessage<ToolSchema_Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolSchema.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "enum", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolSchema_Property {
    return new ToolSchema_Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolSchema_Property {
    return new ToolSchema_Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolSchema_Property {
    return new ToolSchema_Property().fromJsonString(jsonString, options);
  }

  static equals(a: ToolSchema_Property | PlainMessage<ToolSchema_Property> | undefined, b: ToolSchema_Property | PlainMessage<ToolSchema_Property> | undefined): boolean {
    return proto3.util.equals(ToolSchema_Property, a, b);
  }
}

/**
 * *
 * Function definition for a tool
 * Maps to OpenAI's tool.function schema
 *
 * @generated from message repkit.ai.v1.Tool
 */
export class Tool extends Message$1<Tool> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: optional repkit.ai.v1.ToolSchema parameters = 3;
   */
  parameters?: ToolSchema;

  /**
   * For structured outputs
   *
   * @generated from field: bool strict = 4;
   */
  strict = false;

  constructor(data?: PartialMessage<Tool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.Tool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parameters", kind: "message", T: ToolSchema, opt: true },
    { no: 4, name: "strict", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tool {
    return new Tool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tool {
    return new Tool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tool {
    return new Tool().fromJsonString(jsonString, options);
  }

  static equals(a: Tool | PlainMessage<Tool> | undefined, b: Tool | PlainMessage<Tool> | undefined): boolean {
    return proto3.util.equals(Tool, a, b);
  }
}

/**
 * *
 * Tool choice options
 * Specifies how the model should use tools
 *
 * @generated from message repkit.ai.v1.ToolChoice
 */
export class ToolChoice extends Message$1<ToolChoice> {
  /**
   * @generated from oneof repkit.ai.v1.ToolChoice.choice
   */
  choice: {
    /**
     * "auto", "none", "required"
     *
     * @generated from field: string string_choice = 1;
     */
    value: string;
    case: "stringChoice";
  } | {
    /**
     * Call specific function
     *
     * @generated from field: repkit.ai.v1.SpecificTool function = 2;
     */
    value: SpecificTool;
    case: "function";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ToolChoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ToolChoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_choice", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 2, name: "function", kind: "message", T: SpecificTool, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolChoice {
    return new ToolChoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolChoice {
    return new ToolChoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolChoice {
    return new ToolChoice().fromJsonString(jsonString, options);
  }

  static equals(a: ToolChoice | PlainMessage<ToolChoice> | undefined, b: ToolChoice | PlainMessage<ToolChoice> | undefined): boolean {
    return proto3.util.equals(ToolChoice, a, b);
  }
}

/**
 * *
 * Reference to a specific tool function
 *
 * @generated from message repkit.ai.v1.SpecificTool
 */
export class SpecificTool extends Message$1<SpecificTool> {
  /**
   * "function"
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Name of the tool to call
   *
   * @generated from field: string function_name = 2;
   */
  functionName = "";

  constructor(data?: PartialMessage<SpecificTool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.SpecificTool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpecificTool {
    return new SpecificTool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpecificTool {
    return new SpecificTool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpecificTool {
    return new SpecificTool().fromJsonString(jsonString, options);
  }

  static equals(a: SpecificTool | PlainMessage<SpecificTool> | undefined, b: SpecificTool | PlainMessage<SpecificTool> | undefined): boolean {
    return proto3.util.equals(SpecificTool, a, b);
  }
}

/**
 * *
 * Request payload for chat completions
 * Sent to either CreateStandardCompletion or CreateMiniCompletion
 *
 * @generated from message repkit.ai.v1.CreateChatCompletionRequest
 */
export class CreateChatCompletionRequest extends Message$1<CreateChatCompletionRequest> {
  /**
   * @generated from field: repeated repkit.ai.v1.ChatMessage messages = 1;
   */
  messages: ChatMessage[] = [];

  /**
   * @generated from field: optional double temperature = 2;
   */
  temperature?: number;

  /**
   * @generated from field: optional int32 max_tokens = 3;
   */
  maxTokens?: number;

  /**
   * @generated from field: repeated repkit.ai.v1.Tool tools = 4;
   */
  tools: Tool[] = [];

  /**
   * @generated from field: optional repkit.ai.v1.ToolChoice tool_choice = 5;
   */
  toolChoice?: ToolChoice;

  /**
   * Authentication fields (included in proto message, not headers)
   *
   * @generated from field: optional string device_token = 6;
   */
  deviceToken?: string;

  /**
   * @generated from field: optional string timestamp = 7;
   */
  timestamp?: string;

  /**
   * @generated from field: optional string signature = 8;
   */
  signature?: string;

  /**
   * Model selection (allows runtime configuration)
   * Defaults: "gpt-5.2" for standard, "gpt-5-mini" for mini
   *
   * @generated from field: optional string model = 9;
   */
  model?: string;

  constructor(data?: PartialMessage<CreateChatCompletionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.CreateChatCompletionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "messages", kind: "message", T: ChatMessage, repeated: true },
    { no: 2, name: "temperature", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "max_tokens", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "tools", kind: "message", T: Tool, repeated: true },
    { no: 5, name: "tool_choice", kind: "message", T: ToolChoice, opt: true },
    { no: 6, name: "device_token", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateChatCompletionRequest {
    return new CreateChatCompletionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateChatCompletionRequest {
    return new CreateChatCompletionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateChatCompletionRequest {
    return new CreateChatCompletionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateChatCompletionRequest | PlainMessage<CreateChatCompletionRequest> | undefined, b: CreateChatCompletionRequest | PlainMessage<CreateChatCompletionRequest> | undefined): boolean {
    return proto3.util.equals(CreateChatCompletionRequest, a, b);
  }
}

/**
 * *
 * Chat completion response from OpenAI
 *
 * @generated from message repkit.ai.v1.ChatCompletionResponse
 */
export class ChatCompletionResponse extends Message$1<ChatCompletionResponse> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string model = 2;
   */
  model = "";

  /**
   * @generated from field: repeated repkit.ai.v1.Choice choices = 3;
   */
  choices: Choice[] = [];

  /**
   * @generated from field: repkit.ai.v1.Usage usage = 4;
   */
  usage?: Usage;

  /**
   * Unix timestamp as string
   *
   * @generated from field: string created = 5;
   */
  created = "";

  /**
   * "chat.completion"
   *
   * @generated from field: string object = 6;
   */
  object = "";

  constructor(data?: PartialMessage<ChatCompletionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ChatCompletionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "choices", kind: "message", T: Choice, repeated: true },
    { no: 4, name: "usage", kind: "message", T: Usage },
    { no: 5, name: "created", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "object", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatCompletionResponse {
    return new ChatCompletionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatCompletionResponse {
    return new ChatCompletionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatCompletionResponse {
    return new ChatCompletionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ChatCompletionResponse | PlainMessage<ChatCompletionResponse> | undefined, b: ChatCompletionResponse | PlainMessage<ChatCompletionResponse> | undefined): boolean {
    return proto3.util.equals(ChatCompletionResponse, a, b);
  }
}

/**
 * *
 * Single completion choice in response
 *
 * @generated from message repkit.ai.v1.Choice
 */
export class Choice extends Message$1<Choice> {
  /**
   * @generated from field: int32 index = 1;
   */
  index = 0;

  /**
   * @generated from field: repkit.ai.v1.Message message = 2;
   */
  message?: Message;

  /**
   * "stop", "tool_calls", etc.
   *
   * @generated from field: string finish_reason = 3;
   */
  finishReason = "";

  constructor(data?: PartialMessage<Choice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.Choice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "message", T: Message },
    { no: 3, name: "finish_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Choice {
    return new Choice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Choice {
    return new Choice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Choice {
    return new Choice().fromJsonString(jsonString, options);
  }

  static equals(a: Choice | PlainMessage<Choice> | undefined, b: Choice | PlainMessage<Choice> | undefined): boolean {
    return proto3.util.equals(Choice, a, b);
  }
}

/**
 * *
 * Message in a completion choice
 *
 * @generated from message repkit.ai.v1.Message
 */
export class Message extends Message$1<Message> {
  /**
   * "assistant"
   *
   * @generated from field: string role = 1;
   */
  role = "";

  /**
   * @generated from field: optional string content = 2;
   */
  content?: string;

  /**
   * If model called tools
   *
   * @generated from field: repeated repkit.ai.v1.ToolCall tool_calls = 3;
   */
  toolCalls: ToolCall[] = [];

  constructor(data?: PartialMessage<Message>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.Message";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "tool_calls", kind: "message", T: ToolCall, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message {
    return new Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJsonString(jsonString, options);
  }

  static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean {
    return proto3.util.equals(Message, a, b);
  }
}

/**
 * *
 * Token usage information
 *
 * @generated from message repkit.ai.v1.Usage
 */
export class Usage extends Message$1<Usage> {
  /**
   * @generated from field: int32 prompt_tokens = 1;
   */
  promptTokens = 0;

  /**
   * @generated from field: int32 completion_tokens = 2;
   */
  completionTokens = 0;

  /**
   * @generated from field: int32 total_tokens = 3;
   */
  totalTokens = 0;

  /**
   * @generated from field: optional repkit.ai.v1.PromptTokenDetails prompt_tokens_details = 4;
   */
  promptTokensDetails?: PromptTokenDetails;

  constructor(data?: PartialMessage<Usage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.Usage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "prompt_tokens", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "completion_tokens", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "total_tokens", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "prompt_tokens_details", kind: "message", T: PromptTokenDetails, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Usage {
    return new Usage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Usage {
    return new Usage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Usage {
    return new Usage().fromJsonString(jsonString, options);
  }

  static equals(a: Usage | PlainMessage<Usage> | undefined, b: Usage | PlainMessage<Usage> | undefined): boolean {
    return proto3.util.equals(Usage, a, b);
  }
}

/**
 * *
 * Detailed prompt token information
 * Includes cached tokens for cost calculation
 *
 * @generated from message repkit.ai.v1.PromptTokenDetails
 */
export class PromptTokenDetails extends Message$1<PromptTokenDetails> {
  /**
   * @generated from field: int32 cached_tokens = 1;
   */
  cachedTokens = 0;

  constructor(data?: PartialMessage<PromptTokenDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.PromptTokenDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cached_tokens", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromptTokenDetails {
    return new PromptTokenDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromptTokenDetails {
    return new PromptTokenDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromptTokenDetails {
    return new PromptTokenDetails().fromJsonString(jsonString, options);
  }

  static equals(a: PromptTokenDetails | PlainMessage<PromptTokenDetails> | undefined, b: PromptTokenDetails | PlainMessage<PromptTokenDetails> | undefined): boolean {
    return proto3.util.equals(PromptTokenDetails, a, b);
  }
}

/**
 * *
 * Server-streaming chunk for real-time responses
 * Multiple of these are sent for StreamStandardCompletion
 *
 * @generated from message repkit.ai.v1.ChatCompletionChunk
 */
export class ChatCompletionChunk extends Message$1<ChatCompletionChunk> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string model = 2;
   */
  model = "";

  /**
   * @generated from field: repeated repkit.ai.v1.DeltaChoice choices = 3;
   */
  choices: DeltaChoice[] = [];

  /**
   * Unix timestamp as string
   *
   * @generated from field: string created = 4;
   */
  created = "";

  /**
   * "chat.completion.chunk"
   *
   * @generated from field: string object = 5;
   */
  object = "";

  constructor(data?: PartialMessage<ChatCompletionChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.ChatCompletionChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "choices", kind: "message", T: DeltaChoice, repeated: true },
    { no: 4, name: "created", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "object", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatCompletionChunk {
    return new ChatCompletionChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatCompletionChunk {
    return new ChatCompletionChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatCompletionChunk {
    return new ChatCompletionChunk().fromJsonString(jsonString, options);
  }

  static equals(a: ChatCompletionChunk | PlainMessage<ChatCompletionChunk> | undefined, b: ChatCompletionChunk | PlainMessage<ChatCompletionChunk> | undefined): boolean {
    return proto3.util.equals(ChatCompletionChunk, a, b);
  }
}

/**
 * *
 * Delta choice in a streaming chunk
 *
 * @generated from message repkit.ai.v1.DeltaChoice
 */
export class DeltaChoice extends Message$1<DeltaChoice> {
  /**
   * @generated from field: int32 index = 1;
   */
  index = 0;

  /**
   * @generated from field: repkit.ai.v1.Delta delta = 2;
   */
  delta?: Delta;

  /**
   * null until stream ends
   *
   * @generated from field: optional string finish_reason = 3;
   */
  finishReason?: string;

  constructor(data?: PartialMessage<DeltaChoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.DeltaChoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "delta", kind: "message", T: Delta },
    { no: 3, name: "finish_reason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeltaChoice {
    return new DeltaChoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeltaChoice {
    return new DeltaChoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeltaChoice {
    return new DeltaChoice().fromJsonString(jsonString, options);
  }

  static equals(a: DeltaChoice | PlainMessage<DeltaChoice> | undefined, b: DeltaChoice | PlainMessage<DeltaChoice> | undefined): boolean {
    return proto3.util.equals(DeltaChoice, a, b);
  }
}

/**
 * *
 * Delta (incremental change) in a streaming response
 *
 * @generated from message repkit.ai.v1.Delta
 */
export class Delta extends Message$1<Delta> {
  /**
   * Null until content arrives
   *
   * @generated from field: optional string content = 1;
   */
  content?: string;

  /**
   * Null until tool calls arrive
   *
   * @generated from field: repeated repkit.ai.v1.ToolCall tool_calls = 2;
   */
  toolCalls: ToolCall[] = [];

  /**
   * Only in first chunk ("assistant")
   *
   * @generated from field: optional string role = 3;
   */
  role?: string;

  constructor(data?: PartialMessage<Delta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "repkit.ai.v1.Delta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "tool_calls", kind: "message", T: ToolCall, repeated: true },
    { no: 3, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Delta {
    return new Delta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Delta {
    return new Delta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Delta {
    return new Delta().fromJsonString(jsonString, options);
  }

  static equals(a: Delta | PlainMessage<Delta> | undefined, b: Delta | PlainMessage<Delta> | undefined): boolean {
    return proto3.util.equals(Delta, a, b);
  }
}

